FOR ALL TASKS:

INPT==>Input
OTPT==>Output
____________________
[Task-1]
After taking the input and creating my element list (lst) it is passed to the merge sort function that takes it as an array(arr). If the length of that array/list is 1 or 0 then it returns the array as it is already sorted. Else, it takes that array and finds the mid-point by floor dividing it by 2, and it recursively calls itself(Mergesort_function) until the array length is 1 then it passes it to the Merge function, where it takes two arrays and sorts them in N complexity. In this operation, it works using a two-pointer approach similar to the previous lab. 
Finally, it returns the sorted list and the recursive function ends resulting in a sorted list with the help of the divide and conquer technique.Lastly, it is printed in the output.
======================================================================================================================================================================================
[Task-2]
Same as all the tasks after taking the input and making a list named (lst) passed it to the main function biggest_value_finder that uses the divide and conquer technique and divides the 
array into halves each time and for this task for the base case if the array becomes one lenght array it then passes the [O(zero)-->index] value or the single value to the compare function that compares the two values and returns the biggest value. Same merge sort code from the previous task just the compare function is the new addition to it.Lastly we just print the output in the Output file.
======================================================================================================================================================================================
[Task-3]
Took the input and made a list named(lst) same as before. Same as Merge_sort code made a alien function that divides the list into a one lenght list and passes it to my Calculating function or Calc. Calc takes 3 parameters as left sub array right sub array and lastly the alien counter(t_count).Initially t_count is 0. Now for my calc function (Same two pinter approach) initially setted to 0 and if i,j are less than the lenght it will check the conditions in if. Here if the i value is smaller than the j pointer shifts forward(Else statement). But as per instruction if the I value is greate then the i pointer moves forward and count increases permutitavely as i sorted my second list decendingly in order. Lastly if the two lists are not equal then the 
for loops append them into the sorted list. And finally returns a desendent sorted list and the count of the aliens or the logic statement.Finally printed the counter value of the aliens.
======================================================================================================================================================================================
[Task-4]
After taking the input and making the element list(lst) it is sent to the Value_finder that uses divide and conquer and recursively breaks down the list. If we pass an empty list it will give an error.If the list is one lenght than it returns infinity as we took the lowest value possible for the sake of calculation. If the array is two lenght then it does the calculations locally and returns the value. But for a list more than two elements it calls the max index calculator(max_idx_calc) it takes the sub array and divides into two halves and for 1<i<j<n solves and returns the calculated value. Here we used absolute value because ultimately j will be squared and the maximum value of j must be taken.Finally for the last call the maximum of the arrays (Left,Right,big_value)will be returned and it is then printed in the output file.
======================================================================================================================================================================================
[Task-5]
Same as before took the input prepared a list and passed it in my quicksort(sorting function).The sorting function works by taking a array as arr, A lower index 0 in this case left(As it is leftward to ours) and a upper index (right).As quick sort works it checks if i<j and calls the partition function that divides the array in terms of a pivot. The pivot in the partition function compares the numbers in the for loop and smaller elements are swapped in the left and the bigger elements at the right side of the pivot. Finally it returns the index and for the next recursive calls the array can be divided by the returned pivot. And the partition function sorts the passed list. Finally we print the list in the output and this is how quick sort works.

======================================================================================================================================================================================
[Task-6]
Took the input made a list (lst).We took the partition code from the previous task that will return my index of the pivot. Here small function works recursively as if upper is equal to the lower bound or Left==right that means lenght-1 returns that element. If the pivot index is equal to my given index(From query list) than it prints that. If pos is less or greater than pivot it runs that half of the recursion function only rather sorting the full array/list. Finally when the recursive call drops to a single lenght array with the minimum position value it returns that value and using a loop printed the values in the output file.